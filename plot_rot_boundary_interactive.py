import argparse
from typing import List, Optional

import numpy as np


def _parse_z_slices(s: Optional[str]) -> Optional[List[float]]:
    if s is None:
        return None
    s = s.strip()
    if not s:
        return None
    return [float(x.strip()) for x in s.split(",") if x.strip()]


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Interactive 3D plot of Stewart-platform rotation reachability boundary from rot_boundary_z_sweep.npz"
    )
    parser.add_argument(
        "--npz",
        default="rot_boundary_z_sweep.npz",
        help="Path to npz generated by actuation_range.rotation_boundary_for_z_sweep()",
    )
    parser.add_argument(
        "--z-slices",
        default="-20,-10,0,10,20",
        help="Comma-separated z slice locations (mm) to plot (default: -20,-10,0,10,20). Ignored if --all-z is set.",
    )
    parser.add_argument(
        "--all-z",
        action="store_true",
        help="Plot all z slices together, colored by z (more points, but still interactive).",
    )
    parser.add_argument(
        "--point-size",
        type=float,
        default=2.0,
        help="Scatter point size.",
    )
    parser.add_argument(
        "--alpha",
        type=float,
        default=0.25,
        help="Scatter alpha.",
    )
    args = parser.parse_args()

    data = dict(np.load(args.npz, allow_pickle=True))
    z_vals = np.asarray(data["z_vals_mm"], dtype=float)
    dirs = np.asarray(data["dirs"], dtype=float)
    max_deg = np.asarray(data["max_deg"], dtype=float)  # (Nz, Ndirs)

    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection="3d")

    if args.all_z:
        # Build one big point cloud (Nz*Ndirs, 3) and color by z.
        pts = (dirs[None, :, :] * max_deg[:, :, None]).reshape(-1, 3)
        z_rep = np.repeat(z_vals, dirs.shape[0])
        sc = ax.scatter(
            pts[:, 0],
            pts[:, 1],
            pts[:, 2],
            c=z_rep,
            cmap="viridis",
            s=float(args.point_size),
            alpha=float(args.alpha),
        )
        cb = fig.colorbar(sc, ax=ax, shrink=0.7, pad=0.08)
        cb.set_label("z (mm)")
        title = "Reachability boundary (all z colored)"
    else:
        z_slices = _parse_z_slices(args.z_slices) or [-20.0, -10.0, 0.0, 10.0, 20.0]
        # Map z value -> nearest index
        for z0 in z_slices:
            i = int(np.argmin(np.abs(z_vals - float(z0))))
            a = max_deg[i]
            pts = dirs * a[:, None]
            ax.scatter(
                pts[:, 0],
                pts[:, 1],
                pts[:, 2],
                s=float(args.point_size),
                alpha=float(args.alpha),
                label=f"z={z_vals[i]:.0f}mm",
            )
        ax.legend(loc="upper left", fontsize=8)
        title = "Reachability boundary slices (rotation-vector space)"

    ax.set_xlabel("rotvec_x (deg)")
    ax.set_ylabel("rotvec_y (deg)")
    ax.set_zlabel("rotvec_z (deg)")
    ax.set_title(title)

    # Optional: equal-ish scaling for nicer interaction
    # (Matplotlib doesn't do true equal aspect in 3D, but this helps.)
    xyz = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()])
    spans = xyz[:, 1] - xyz[:, 0]
    centers = xyz.mean(axis=1)
    r = 0.5 * float(spans.max())
    ax.set_xlim(centers[0] - r, centers[0] + r)
    ax.set_ylim(centers[1] - r, centers[1] + r)
    ax.set_zlim(centers[2] - r, centers[2] + r)

    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()


